<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <title>Three.js - Locked Panel & Billboarding</title>
  <link rel='stylesheet' href='./css/common.css'>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <header style="pointer-events: none;">
    <details open>
      <summary>Pannello Intelligente</summary>
      <p>Pizzica la sfera rossa per BLOCCARE il pannello. Il frontale ti guarderà sempre.</p>
      <a class="back" href="./" style="pointer-events: auto;">Indietro</a>
    </details>
  </header>

  <script type="module">
import * as THREE from 'three';
import { ARButton } from 'three/addons/webxr/ARButton.js';
import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

document.body.appendChild(ARButton.createButton(renderer, { 
  optionalFeatures: ['hand-tracking'] 
}));

scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1));

// --- STATO GLOBALE ---
let isLocked = false;

// --- CREAZIONE PANNELLO (DINAMICO) ---
// --- 1. IL PANNELLO (Contenuto passivo) ---
const textureLoader = new THREE.TextureLoader();
const myTexture = textureLoader.load('./texture/image/polipo.png');

const panel = new THREE.Mesh(
  new THREE.BoxGeometry(0.45, 0.30, 0.01),
  new THREE.MeshBasicMaterial({ map: myTexture })
);

// IMPORTANTE: Togliamo draggable dal panel, non vogliamo muoverlo toccando il quadro
panel.userData.draggable = false; 
scene.add(panel);

// --- 2. LA PALLINA (Ancora di controllo) ---
const lockBtn = new THREE.Mesh(
  new THREE.SphereGeometry(0.03),
  new THREE.MeshBasicMaterial({ color: 0xff0000 })
);

// Posizionamento
lockBtn.position.set(0.22, 0.15, 0.02);

// CONFIGURAZIONE DINAMICA
lockBtn.userData.isActionButton = true; // Serve per il click (Lock)
lockBtn.userData.isAnchor = true;       // Serve per dire "Io sono un'ancora"
lockBtn.userData.controlledObject = panel; // <--- Legame: questa pallina muove il panel

lockBtn.userData.onClick = () => {
  isLocked = !isLocked;
  lockBtn.material.color.set(isLocked ? 0x00ff00 : 0xff0000);
};

// La aggiungiamo al pannello così se il pannello si muove, lei resta nell'angolo
panel.add(lockBtn);

// --- GESTIONE CONTROLLER INDIPENDENTI ---
const handModels = new XRHandModelFactory();
const controllers = {
  left: { hand: renderer.xr.getHand(0), grabbedObject: null, lastPinch: false },
  right: { hand: renderer.xr.getHand(1), grabbedObject: null, lastPinch: false }
};

[controllers.left, controllers.right].forEach(c => {
  c.hand.add(handModels.createHandModel(c.hand, 'mesh'));
  scene.add(c.hand);
});
// --- 3. LOGICA DI INTERAZIONE AGGIORNATA ---
function handleInteraction(controllerObj) {
  const { hand } = controllerObj;
  const indexTip = hand.joints['index-finger-tip'];
  const thumbTip = hand.joints['thumb-tip'];

  if (!indexTip || !thumbTip || !indexTip.position) return;

  const isPinching = indexTip.position.distanceTo(thumbTip.position) < 0.035;

  if (isPinching) {
    if (!controllerObj.grabbedObject) {
      // Controlliamo cosa abbiamo "pizzicato"
      scene.traverse((obj) => {
        const worldPos = new THREE.Vector3();
        obj.getWorldPosition(worldPos);

        if (indexTip.position.distanceTo(worldPos) < 0.07) {
          // Se pizzichiamo l'ancora (la pallina)
          if (obj.userData.isAnchor) {
            controllerObj.grabbedObject = obj;
          }
          // Se è un bottone, eseguiamo l'azione una volta sola
          if (obj.userData.isActionButton && !controllerObj.lastPinch) {
            obj.userData.onClick();
          }
        }
      });
    }

    // SE STIAMO TRASCINANDO L'ANCORA
    if (controllerObj.grabbedObject) {
      const anchor = controllerObj.grabbedObject;
      const target = anchor.userData.controlledObject; // Il nostro panel

      if (target) {
        // Calcoliamo la posizione globale dell'ancora rispetto al target
        // per evitare che il pannello "salti" al centro della mano
        const offset = new THREE.Vector3().copy(anchor.position);
        offset.applyQuaternion(target.quaternion); 
        
        // Muoviamo il pannello in modo che l'ancora resti sotto le dita
        target.position.subVectors(indexTip.position, offset);
      }
    }
  } else {
    controllerObj.grabbedObject = null;
  }
  controllerObj.lastPinch = isPinching;
}

renderer.setAnimationLoop(() => {
  panel.lookAt(camera.position);

  const isBeingGrabbed = controllers.left.grabbedObject || controllers.right.grabbedObject;
  
  if (!isLocked && !isBeingGrabbed) {
    const distance = 0.45; 
    const targetPos = new THREE.Vector3(0, 0, -distance);
    targetPos.applyMatrix4(camera.matrixWorld);
    panel.position.lerp(targetPos, 0.1);
  }

  handleInteraction(controllers.left);
  handleInteraction(controllers.right);
  
  renderer.render(scene, camera);
});
  </script>
</body>
</html>