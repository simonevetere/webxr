<!doctype html>
<html>

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <link rel='icon' type='image/png' sizes='32x32' href='./favicon-32x32.png'>
  <link rel='icon' type='image/png' sizes='96x96' href='./favicon-96x96.png'>
  <link rel='stylesheet' href='./css/common.css'>

  <title>AR Solar System with Hands</title>
</head>

<body>
  <header>
    <details open>
      <summary>AR Solar System & Hands</summary>
      <p>
        In questo esempio vedrai il sistema solare e le tue mani (rappresentate da cubi) in Realt√† Aumentata.
        <a class="back" href="./">Back</a>
      </p>
    </details>
  </header>
  <main style='text-align: center;'>
    <p>Click 'Enter XR' to see content</p>
  </main>
  <script type="module">
    import { WebXRButton } from './js/util/webxr-button.js';
    import { Scene } from './js/render/scenes/scene.js';
    import { Node } from './js/render/core/node.js';
    import { Renderer, createWebGLContext } from './js/render/core/renderer.js';
    import { Gltf2Node } from './js/render/nodes/gltf2.js';
    import { SkyboxNode } from './js/render/nodes/skybox.js';
    import { BoxBuilder } from './js/render/geometry/box-builder.js';
    import { PbrMaterial } from './js/render/materials/pbr.js';
    import { QueryArgs } from './js/util/query-args.js';
    import { mat4 } from './js/render/math/gl-matrix.js';
    import { vec3 } from './js/render/math/gl-matrix.js';
    import { Ray } from './js/render/math/ray.js';

    import { fetchProfile } from 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/motion-controllers@1.0/dist/motion-controllers.module.js';

    const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';

    // XR globals.
    let xrButton = null;
    let xrRefSpace = null;
    let isAR = true; // Forziamo AR come predefinito
    let radii = new Float32Array(25);
    let positions = new Float32Array(16 * 25);

    // Boxes per le mani
    let boxes_left = [];
    let boxes_right = [];
    let boxes_none = [];
    let tracked_boxes_left = [];
    let tracked_boxes_right = [];
    let tracked_boxes_none = [];
    let boxes = { input_left: boxes_left, input_right: boxes_right, input_none: boxes_none, tracked_left: tracked_boxes_left, tracked_right: tracked_boxes_right, tracked_none: tracked_boxes_none };
    let indexFingerBoxes = { input_left: null, input_right: null, tracked_left: null, tracked_right: null };
    const defaultBoxColor = {r: 0.5, g: 0.5, b: 0.5};
    const leftBoxColor = {r: 1, g: 0, b: 1};
    const rightBoxColor = {r: 0, g: 1, b: 1};
    let interactionBox = null;
    let leftInteractionBox = null;
    let rightInteractionBox = null;

    // WebGL scene globals.
    let gl = null;
    let renderer = null;
    let scene = new Scene();

    // AGGIUNTA SISTEMA SOLARE (dall'esempio AR)
    let solarSystem = new Gltf2Node({ url: 'media/gltf/space/space.gltf' });
    solarSystem.scale = [0.1, 0.1, 0.1];
    scene.addNode(solarSystem);

    // Skybox (visibile solo in inline/VR)
    let skybox = new SkyboxNode({ url: 'media/textures/milky-way-4k.png' });
    scene.addNode(skybox);

    function createBoxPrimitive(r, g, b) {
      let boxBuilder = new BoxBuilder();
      boxBuilder.pushCube([0, 0, 0], 1);
      let boxPrimitive = boxBuilder.finishPrimitive(renderer);
      let boxMaterial = new PbrMaterial();
      boxMaterial.baseColorFactor.value = [r, g, b, 1];
      return renderer.createRenderPrimitive(boxPrimitive, boxMaterial);
    }

    function addBox(r, g, b) {
      let boxRenderPrimitive = createBoxPrimitive(r, g, b);
      let boxNode = new Node();
      boxNode.addRenderPrimitive(boxRenderPrimitive);
      // Marks the node as one that needs to be checked when hit testing.
      boxNode.selectable = true;
      return boxNode;
    }

    function initHands() {
      for (const box of boxes_left) {
        scene.removeNode(box);
      }
      for (const box of boxes_right) {
        scene.removeNode(box);
      }
      boxes_left = [];
      boxes_right = [];
      boxes = { input_left: boxes_left, input_right: boxes_right, input_none: boxes_none, tracked_left: tracked_boxes_left, tracked_right: tracked_boxes_right, tracked_none: tracked_boxes_none };
      if (typeof XRHand !== 'undefined') {
        for (let i = 0; i <= 24; i++) {
          const r = .6 + Math.random() * .4;
          const g = .6 + Math.random() * .4;
          const b = .6 + Math.random() * .4;
          boxes_left.push(addBox(0, 0, 0, r, g, b));
          boxes_right.push(addBox(0, 0, 0, r, g, b));
          tracked_boxes_left.push(addBox(0, 0, 0, r, g, b));
          tracked_boxes_right.push(addBox(0, 0, 0, r, g, b));
        }
      }
      if (indexFingerBoxes.input_left) {
        scene.removeNode(indexFingerBoxes.left);
      }
      if (indexFingerBoxes.input_right) {
        scene.removeNode(indexFingerBoxes.input_right);
      }
      if (indexFingerBoxes.tracked_left) {
        scene.removeNode(indexFingerBoxes.tracked_left);
      }
      if (indexFingerBoxes.tracked_right) {
        scene.removeNode(indexFingerBoxes.tracked_right);
      }
      indexFingerBoxes.input_left = addBox(0, 0, 0, leftBoxColor.r, leftBoxColor.g, leftBoxColor.b);
      indexFingerBoxes.input_right = addBox(0, 0, 0, rightBoxColor.r, rightBoxColor.g, rightBoxColor.b);
      indexFingerBoxes.tracked_left = addBox(0, 0, 0, leftBoxColor.r, leftBoxColor.g, leftBoxColor.b);
      indexFingerBoxes.tracked_right = addBox(0, 0, 0, rightBoxColor.r, rightBoxColor.g, rightBoxColor.b);
    }

    function initXR() {
      xrButton = new WebXRButton({
        onRequestSession: onRequestSession,
        onEndSession: onEndSession
      });
      document.querySelector('header').appendChild(xrButton.domElement);

      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          xrButton.enabled = supported;
        });
      }
    }

    function onRequestSession() {
      return navigator.xr.requestSession('immersive-ar', { 
        optionalFeatures: ['local-floor', 'hand-tracking'] 
      }).then(onSessionStarted);
    }

    function onSessionStarted(session) {
      xrButton.setSession(session);
      session.addEventListener('end', onSessionEnded);
      session.addEventListener('inputsourceschange', onInputSourcesChange);
      // trackedSources are still experimental. Don't rely on this feature yet.
      session.addEventListener('trackedsourceschange', onInputSourcesChange);

      session.addEventListener('visibilitychange', e => {
        // remove hand controller while blurred
        if(e.session.visibilityState === 'visible-blurred') {
          for (const box of boxes['input_left']) {
            scene.removeNode(box);
          }
          for (const box of boxes['input_right']) {
            scene.removeNode(box);
          }
          for (const box of boxes['tracked_left']) {
            scene.removeNode(box);
          }
          for (const box of boxes['tracked_right']) {
            scene.removeNode(box);
          }
        }
      });

      // Create a WebGL context to render with, initialized to be compatible
      // with the XRDisplay we're presenting to.
      gl = createWebGLContext({
        xrCompatible: true
      });

      // Create a renderer with that GL context (this is just for the samples
      // framework and has nothing to do with WebXR specifically.)
      renderer = new Renderer(gl);
      initHands();
      scene.setRenderer(renderer);

      session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

      session.requestReferenceSpace('local').then((refSpace) => {
        xrRefSpace = refSpace;
        session.requestAnimationFrame(onXRFrame);
      });
    }

    function onEndSession(session) {
      session.end();
    }

    function onSessionEnded(event) {
      xrButton.setSession(null);

      // In this simple case discard the WebGL context too, since we're not
      // rendering anything else to the screen with it.
      renderer = null;
    }

    function onInputSourcesChange(event) {
      onSourcesChange(event, "input_");
    }

    function onTrackedSourcesChange(event) {
      onSourcesChange(event, "tracked_");
    }

    function onSourcesChange(event, type) {
        // As input sources are connected if they are tracked-pointer devices
        // look up which meshes should be associated with their profile and
        // load as the controller model for that hand.
        for (let inputSource of event.added) {
          if (inputSource.targetRayMode == 'tracked-pointer') {
            // Use the fetchProfile method from the motionControllers library
            // to find the appropriate glTF mesh path for this controller.
            fetchProfile(inputSource, DEFAULT_PROFILES_PATH).then(({profile, assetPath}) => {
              // Typically if you wanted to animate the controllers in response
              // to device inputs you'd create a new MotionController() instance
              // here to handle the animation, but this sample will skip that
              // and only display a static mesh for simplicity.

              scene.inputRenderer.setControllerMesh(new Gltf2Node({url: assetPath}), inputSource.handedness, inputSource.profiles[0]);
            });
          }
        }
      }

    function updateInputSources(session, frame, refSpace) {
      updateSources(session, frame, refSpace, session.inputSources, "input_");
    }

    function updateTrackedSources(session, frame, refSpace) {
      // session.trackedSources are still experimental. Don't rely on this feature yet.
      if (session.trackedSources) {
        updateSources(session, frame, refSpace, session.trackedSources, "tracked_");
      }
    }

    function updateSources(session, frame, refSpace, sources, type) {
      if(session.visibilityState === 'visible-blurred') {
        return;
      }
      for (let inputSource of sources) {
        let hand_type = type + inputSource.handedness;
        if (type == "input_") {
          let targetRayPose = frame.getPose(inputSource.targetRaySpace, refSpace);
          if (targetRayPose) {
            if (inputSource.targetRayMode == 'tracked-pointer') {
              scene.inputRenderer.addLaserPointer(targetRayPose.transform);
            }

            let targetRay = new Ray(targetRayPose.transform);
            let cursorDistance = 2.0;
            let cursorPos = vec3.fromValues(
                targetRay.origin.x,
                targetRay.origin.y,
                targetRay.origin.z
                );
            vec3.add(cursorPos, cursorPos, [
                targetRay.direction.x * cursorDistance,
                targetRay.direction.y * cursorDistance,
                targetRay.direction.z * cursorDistance,
                ]);

            scene.inputRenderer.addCursor(cursorPos);
          }
        }

        if (!inputSource.hand && inputSource.gripSpace) {
          let gripPose = frame.getPose(inputSource.gripSpace, refSpace);
          if (gripPose) {
            scene.inputRenderer.addController(gripPose.transform.matrix, inputSource.handedness, inputSource.profiles[0]);
          } else {
            scene.inputRenderer.hideController(hand_type);
          }
        }

        let offset = 0;
        if (!inputSource.hand) {
          for (const box of boxes[hand_type] || []) {
            scene.removeNode(box);
          }
          continue;
        }

        if (frame.fillJointRadii(inputSource.hand.values(), radii) &&
            frame.fillPoses(inputSource.hand.values(), refSpace, positions)) {
          
          let offset = 0;
          for (const box of boxes[hand_type]) {
            scene.addNode(box);
            let matrix = positions.slice(offset * 16, (offset + 1) * 16);
            let jointRadius = radii[offset];
            mat4.getTranslation(box.translation, matrix);
            mat4.getRotation(box.rotation, matrix);
            box.scale = [jointRadius, jointRadius, jointRadius];
          }
            
          // Render a special box for each index finger on each hand  
          const indexFingerBox = indexFingerBoxes[hand_type];
          scene.addNode(indexFingerBox);  
          let joint = inputSource.hand.get('index-finger-tip'); 
          let jointPose = frame.getJointPose(joint, xrRefSpace);  
          if (jointPose) {  
            let matrix = jointPose.transform.matrix;
            mat4.getTranslation(indexFingerBox.translation, matrix);
            mat4.getRotation(indexFingerBox.rotation, matrix);
            indexFingerBox.scale = [0.02, 0.02, 0.02];  
          }
        }
      }
    }
    
    function UpdateInteractables(time) {
      // Add scene objects if not present
      if (!interactionBox) {  
        // Add box to demonstrate hand interaction
        function AddInteractionBox(r, g, b) { 
          let box = new Node(); 
          box.addRenderPrimitive(createBoxPrimitive(r, g, b));  
          box.translation = [0, 0, -0.65];  
          box.scale = [0.25, 0.25, 0.25]; 
          return box; 
        } 
        interactionBox = AddInteractionBox(defaultBoxColor.r, defaultBoxColor.g, defaultBoxColor.b);  
        leftInteractionBox = AddInteractionBox(leftBoxColor.r, leftBoxColor.g, leftBoxColor.b); 
        rightInteractionBox = AddInteractionBox(rightBoxColor.r, rightBoxColor.g, rightBoxColor.b); 
        scene.addNode(interactionBox);  
        scene.addNode(leftInteractionBox);  
        scene.addNode(rightInteractionBox); 
      }
      
      function Distance(nodeA, nodeB) { 
        return Math.sqrt( 
          Math.pow(nodeA.translation[0] - nodeB.translation[0], 2) +  
          Math.pow(nodeA.translation[1] - nodeB.translation[1], 2) +  
          Math.pow(nodeA.translation[2] - nodeB.translation[2], 2));  
      }

      // Perform distance check on interactable elements
      const interactionDistance = interactionBox.scale[0];  
      leftInteractionBox.visible = false; 
      rightInteractionBox.visible = false;  
      if (Distance(indexFingerBoxes.input_left, interactionBox) < interactionDistance) {
        leftInteractionBox.visible = true;  
      } else if (Distance(indexFingerBoxes.input_right, interactionBox) < interactionDistance) {
        rightInteractionBox.visible = true; 
      } 
      interactionBox.visible = !(leftInteractionBox.visible || rightInteractionBox.visible);
      
      mat4.rotateX(interactionBox.matrix, interactionBox.matrix, time/1000);
      mat4.rotateY(interactionBox.matrix, interactionBox.matrix, time/1500);
      leftInteractionBox.matrix = interactionBox.matrix;
      rightInteractionBox.matrix = interactionBox.matrix;
    }

    function onXRFrame(t, frame) {
      let session = frame.session;
      scene.startFrame();
      session.requestAnimationFrame(onXRFrame);

      updateInputSources(session, frame, xrRefSpace);
      updateTrackedSources(session, frame, xrRefSpace);
      UpdateInteractables(t);

      let pose = frame.getViewerPose(xrRefSpace);
      if (pose) {
        let glLayer = session.renderState.baseLayer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        for (let view of pose.views) {
          let viewport = glLayer.getViewport(view);
          gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
          scene.draw(view.projectionMatrix, view.transform);
        }
      }
      scene.endFrame();
    }

    initXR();
  </script>
</body>
</html>
