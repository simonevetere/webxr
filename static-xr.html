<!doctype html>
<html>

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <link rel='icon' type='image/png' sizes='32x32' href='./favicon-32x32.png'>
  <link rel='icon' type='image/png' sizes='96x96' href='./favicon-96x96.png'>
  <link rel='stylesheet' href='./css/common.css'>
  <title>Immersive Session with Tablet</title>
</head>

<body>
  <header>
    <details open>
      <summary>WebXR Tablet Session</summary>
      <p>
        Usa il pizzico (indice-pollice) per afferrare e spostare il tablet.
        <a class="back" href="./">Back</a>
      </p>
    </details>
  </header>
  <main style='text-align: center;'>
    <p>Click 'Enter XR' to see content</p>
  </main>
  <script type="module">
    import { WebXRButton } from './js/util/webxr-button.js';
    import { Scene } from './js/render/scenes/scene.js';
    import { Node } from './js/render/core/node.js';
    import { Renderer, createWebGLContext } from './js/render/core/renderer.js';
    import { Gltf2Node } from './js/render/nodes/gltf2.js';
    import { SkyboxNode } from './js/render/nodes/skybox.js';
    import { BoxBuilder } from './js/render/geometry/box-builder.js';
    import { PbrMaterial } from './js/render/materials/pbr.js';
    import { QueryArgs } from './js/util/query-args.js';
    import { mat4 } from './js/render/math/gl-matrix.js';
    import { vec3 } from './js/render/math/gl-matrix.js';
    import { Ray } from './js/render/math/ray.js';
    import { fetchProfile } from 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/motion-controllers@1.0/dist/motion-controllers.module.js';

    const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';

    // XR globals.
    let xrButton = null;
    let xrRefSpace = null;
    let isAR = true;
    let radii = new Float32Array(25);
    let positions = new Float32Array(16 * 25);

    // Hands/Boxes globals
    let boxes_left = [], boxes_right = [], boxes_none = [];
    let tracked_boxes_left = [], tracked_boxes_right = [], tracked_boxes_none = [];
    let boxes = { input_left: boxes_left, input_right: boxes_right, input_none: boxes_none, tracked_left: tracked_boxes_left, tracked_right: tracked_boxes_right, tracked_none: tracked_boxes_none };
    let indexFingerBoxes = { input_left: null, input_right: null, tracked_left: null, tracked_right: null };
    const leftBoxColor = { r: 1, g: 0, b: 1 };
    const rightBoxColor = { r: 0, g: 1, b: 1 };

    // --- NUOVE GLOBALI PER INTERAZIONE ---
    let interactables = [];
    let grabbedObjects = { left: null, right: null };

    // WebGL scene globals.
    let gl = null;
    let renderer = null;
    let scene = new Scene();
    scene.enableStats(false);

    // --- FUNZIONI TABLET ---
    function createTabletNode(text) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 256;

      const draw = (txt) => {
        ctx.fillStyle = '#333'; ctx.fillRect(0, 0, 512, 256); // Cornice
        ctx.fillStyle = '#fff'; ctx.fillRect(15, 15, 482, 226); // Schermo
        ctx.fillStyle = '#000'; ctx.font = 'bold 35px Arial'; ctx.textAlign = 'center';
        const lines = txt.split('\n');
        lines.forEach((l, i) => ctx.fillText(l, 256, 110 + (i * 45)));
      };

      draw(text);
      const texture = renderer.createTextureFromSource(canvas);
      const boxBuilder = new BoxBuilder();
      boxBuilder.pushCube([0, 0, 0], 1);
      const primitive = boxBuilder.finishPrimitive(renderer);
      const material = new PbrMaterial();
      material.baseColorTexture.texture = texture;
      material.emissiveFactor.value = [0.3, 0.3, 0.3];

      const node = new Node();
      node.addRenderPrimitive(renderer.createRenderPrimitive(primitive, material));
      node.scale = [0.4, 0.25, 0.015]; // Proporzioni Tablet

      return { node, update: (nt) => { draw(nt); texture.updateGeometry(); } };
    }

    function addInteractable(item, pos = [0, 1.2, -0.6]) {
      item.node.translation = pos;
      let data = { node: item.node, radius: 0.25, tabletControl: item };
      interactables.push(data);
      scene.addNode(item.node);
      return data;
    }

    // --- LOGICA ORIGINALE MANI/BOXES ---
    function createBoxPrimitive(r, g, b) {
      let boxBuilder = new BoxBuilder();
      boxBuilder.pushCube([0, 0, 0], 1);
      let boxPrimitive = boxBuilder.finishPrimitive(renderer);
      let boxMaterial = new PbrMaterial();
      boxMaterial.baseColorFactor.value = [r, g, b, 1];
      return renderer.createRenderPrimitive(boxPrimitive, boxMaterial);
    }

    function addBox(x, y, z, r, g, b) {
      let boxNode = new Node();
      boxNode.addRenderPrimitive(createBoxPrimitive(r, g, b));
      return boxNode;
    }

    function initHands() {
      boxes_left = []; boxes_right = [];
      boxes = { input_left: boxes_left, input_right: boxes_right, input_none: boxes_none, tracked_left: tracked_boxes_left, tracked_right: tracked_boxes_right, tracked_none: tracked_boxes_none };
      if (typeof XRHand !== 'undefined') {
        for (let i = 0; i <= 24; i++) {
          const r = .6 + Math.random() * .4; const g = .6 + Math.random() * .4; const b = .6 + Math.random() * .4;
          boxes_left.push(addBox(0, 0, 0, r, g, b));
          boxes_right.push(addBox(0, 0, 0, r, g, b));
          tracked_boxes_left.push(addBox(0, 0, 0, r, g, b));
          tracked_boxes_right.push(addBox(0, 0, 0, r, g, b));
        }
      }
      indexFingerBoxes.input_left = addBox(0, 0, 0, leftBoxColor.r, leftBoxColor.g, leftBoxColor.b);
      indexFingerBoxes.input_right = addBox(0, 0, 0, rightBoxColor.r, rightBoxColor.g, rightBoxColor.b);
      indexFingerBoxes.tracked_left = addBox(0, 0, 0, leftBoxColor.r, leftBoxColor.g, leftBoxColor.b);
      indexFingerBoxes.tracked_right = addBox(0, 0, 0, rightBoxColor.r, rightBoxColor.g, rightBoxColor.b);
    }

    function initXR() {
      xrButton = new WebXRButton({ onRequestSession: onRequestSession, onEndSession: (s) => s.end() });
      document.querySelector('header').appendChild(xrButton.domElement);
      if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-vr').then((s) => {
          xrButton.enabled = s;
          if (!s) navigator.xr.isSessionSupported('immersive-ar').then(s2 => { isAR = true; xrButton.enabled = s2; });
        });
      }
    }

    function onRequestSession() {
      return navigator.xr.requestSession(isAR ? 'immersive-ar' : 'immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'] }).then(onSessionStarted);
    }

    function onSessionStarted(session) {
      xrButton.setSession(session);
      session.addEventListener('end', () => xrButton.setSession(null));
      session.addEventListener('inputsourceschange', onInputSourcesChange);

      gl = createWebGLContext({ xrCompatible: true });
      renderer = new Renderer(gl);
      scene.setRenderer(renderer);

      initHands();

      // --- SOSTITUZIONE SUNFLOWER CON TABLET ---
      let myTablet = createTabletNode("DISPOSITIVO VR\nAfferra e sposta");
      addInteractable(myTablet, [0, 1.3, -0.5]);

      session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
      session.requestReferenceSpace('local').then((refSpace) => {
        xrRefSpace = refSpace;
        session.requestAnimationFrame(onXRFrame);
      });
    }

    // --- FUNZIONI DI AGGIORNAMENTO (ORIGINALI + NUOVE) ---
    function onInputSourcesChange(event) {
      for (let inputSource of event.added) {
        if (inputSource.targetRayMode == 'tracked-pointer') {
          fetchProfile(inputSource, DEFAULT_PROFILES_PATH).then(({ assetPath }) => {
            scene.inputRenderer.setControllerMesh(new Gltf2Node({ url: assetPath }), inputSource.handedness, inputSource.profiles[0]);
          });
        }
      }
    }

    function updateSources(session, frame, refSpace) {
      if (session.visibilityState === 'visible-blurred') return;
      for (let inputSource of session.inputSources) {
        let hand_type = "input_" + inputSource.handedness;
        let targetRayPose = frame.getPose(inputSource.targetRaySpace, refSpace);
        if (targetRayPose) {
          if (inputSource.targetRayMode == 'tracked-pointer') scene.inputRenderer.addLaserPointer(targetRayPose.transform);
        }

        if (!inputSource.hand && inputSource.gripSpace) {
          let gripPose = frame.getPose(inputSource.gripSpace, refSpace);
          if (gripPose) scene.inputRenderer.addController(gripPose.transform.matrix, inputSource.handedness, inputSource.profiles[0]);
        }

        if (inputSource.hand) {
          if (frame.fillJointRadii(inputSource.hand.values(), radii) && frame.fillPoses(inputSource.hand.values(), refSpace, positions)) {
            let offset = 0;
            for (const box of boxes[hand_type]) {
              scene.addNode(box);
              let matrix = positions.slice(offset * 16, (offset + 1) * 16);
              mat4.getTranslation(box.translation, matrix);
              mat4.getRotation(box.rotation, matrix);
              let r = radii[offset++]; box.scale = [r, r, r];
            }
            // Index tip box
            const indexBox = indexFingerBoxes[hand_type];
            scene.addNode(indexBox);
            let jointPose = frame.getJointPose(inputSource.hand.get('index-finger-tip'), refSpace);
            if (jointPose) {
              mat4.getTranslation(indexBox.translation, jointPose.transform.matrix);
              mat4.getRotation(indexBox.rotation, jointPose.transform.matrix);
              indexBox.scale = [0.02, 0.02, 0.02];
            }
          }
        }
      }
    }

    function UpdateInteractables(frame, refSpace) {
      for (let inputSource of frame.session.inputSources) {
        if (!inputSource.hand) continue;
        let hand = inputSource.handedness;
        let thumbPose = frame.getJointPose(inputSource.hand.get('thumb-tip'), refSpace);
        let indexPose = frame.getJointPose(inputSource.hand.get('index-finger-tip'), refSpace);

        if (thumbPose && indexPose) {
          let p1 = thumbPose.transform.position;
          let p2 = indexPose.transform.position;
          let dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
          let pinchPos = [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2];

          if (dist < 0.035) {
            if (grabbedObjects[hand]) {
              let obj = grabbedObjects[hand];
              obj.translation = pinchPos;
              mat4.fromRotationTranslationScale(obj.matrix, [0, 0, 0, 1], pinchPos, obj.scale);
            } else {
              for (let it of interactables) {
                let d = Math.sqrt(Math.pow(pinchPos[0] - it.node.translation[0], 2) + Math.pow(pinchPos[1] - it.node.translation[1], 2) + Math.pow(pinchPos[2] - it.node.translation[2], 2));
                if (d < it.radius) grabbedObjects[hand] = it.node;
              }
            }
          } else { grabbedObjects[hand] = null; }
        }
      }
    }

    function onXRFrame(t, frame) {
      scene.startFrame();
      frame.session.requestAnimationFrame(onXRFrame);
      updateSources(frame.session, frame, xrRefSpace);
      UpdateInteractables(frame, xrRefSpace);

      let pose = frame.getViewerPose(xrRefSpace);
      if (pose) {
        let glLayer = frame.session.renderState.baseLayer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        for (let view of pose.views) {
          let vp = glLayer.getViewport(view);
          gl.viewport(vp.x, vp.y, vp.width, vp.height);
          scene.draw(view.projectionMatrix, view.transform);
        }
      }
      scene.endFrame();
    }

    initXR();
  </script>
</body>

</html>